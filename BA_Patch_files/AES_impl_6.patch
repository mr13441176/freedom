--- aes.c	2020-02-22 15:21:14.646130000 +0900
+++ aes2.c	2020-02-18 20:31:15.652878000 +0900
@@ -423,7 +423,7 @@
 static void Cipher(state_t* state, const uint8_t* RoundKey)
 {
   uint8_t round = 0;
-
+  UART0_REG(AES_REG_TRIGGER) = 1;
   // Add the First round key to the state before starting the rounds.
   AddRoundKey(0, state, RoundKey); 
   
@@ -443,13 +443,14 @@
   SubBytes(state);
   ShiftRows(state);
   AddRoundKey(Nr, state, RoundKey);
+  UART0_REG(AES_REG_TRIGGER) = 0;
 }
 
 #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
 static void InvCipher(state_t* state, const uint8_t* RoundKey)
 {
   uint8_t round = 0;
-
+  UART0_REG(AES_REG_TRIGGER) = 1;
   // Add the First round key to the state before starting the rounds.
   AddRoundKey(Nr, state, RoundKey); 
 
@@ -469,6 +470,7 @@
   InvShiftRows(state);
   InvSubBytes(state);
   AddRoundKey(0, state, RoundKey);
+  UART0_REG(AES_REG_TRIGGER) = 0;
 }
 #endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)
 
@@ -618,7 +620,7 @@
     // print text to encrypt, key and IV
     puts("ECB encrypt verbose:\r\n");
     puts("plain text:\r\n");
-    for (i = (uint8_t) 0; i < (uint8_t) 4; ++i)
+    for (i = (uint8_t) 0; i < (uint8_t) 1; ++i)
     {
         phex(plain_text + i * (uint8_t) 16);
     }
@@ -634,7 +636,7 @@
     struct AES_ctx ctx;
     AES_init_ctx(&ctx, key);
 
-    for (i = 0; i < 4; ++i)
+    for (i = 0; i < 1; ++i)
     {
       AES_ECB_encrypt(&ctx, plain_text + (i * 16));
       phex(plain_text + (i * 16));
@@ -852,9 +854,50 @@
     }
 }
 
+void test_encrypt_ecb_scan(void)
+{
+    // Example of more verbose verification
+
+    uint8_t i,j;
+    void *uart = (void*)UART0_CTRL_ADDR;
+
+    // 128bit key
+    uint8_t key[16] =        { (uint8_t) 0x2b, (uint8_t) 0x7e, (uint8_t) 0x15, (uint8_t) 0x16, (uint8_t) 0x28, (uint8_t) 0xae, (uint8_t) 0xd2, (uint8_t) 0xa6, (uint8_t) 0xab, (uint8_t) 0xf7, (uint8_t) 0x15, (uint8_t) 0x88, (uint8_t) 0x09, (uint8_t) 0xcf, (uint8_t) 0x4f, (uint8_t) 0x3c };
+    // 512bit text
+    uint8_t plain_text[16];
+
+    // print text to encrypt, key and IV
+     puts("ECB encrypt scan:\r\n");
+    // scan for input plaintext from uart
+    for (j = (uint8_t) 0; j < (uint8_t) 16; j++)
+    {
+        plain_text[j] = uart_getc(uart);
+        //uart_put_hex8(uart,plain_text[j]);
+
+    }
+    puts("recieved plaintext is:\r\n");
+    phex(plain_text);
+    puts("\r\n");
+
+    puts("key:\r\n");
+    phex(key);
+    puts("\r\n");
+
+    // print the resulting cipher as 4 x 16 byte strings
+    puts("ciphertext:\r\n");
+    
+    struct AES_ctx ctx;
+    AES_init_ctx(&ctx, key);
+
+    AES_ECB_encrypt(&ctx, plain_text);
+    phex(plain_text);
+    puts("\r\n");
+}
+
 int test_all(void)
 {
     int exit;
+    int i;
 
 #if defined(AES256)
     puts("Testing AES256");
@@ -869,11 +912,15 @@
     puts("You need to specify a symbol between AES128, AES192 or AES256. Exiting");
     return 0;
 #endif
-
-    exit = test_encrypt_cbc() + test_decrypt_cbc() +
-  test_encrypt_ctr() + test_decrypt_ctr() +
-  test_decrypt_ecb() + test_encrypt_ecb();
-    test_encrypt_ecb_verbose();
+    for (i = 0; i < 20000; ++i)
+      {
+        //test_encrypt_ecb_verbose();
+        test_encrypt_ecb_scan();
+      }
+    //exit = //test_encrypt_cbc() + test_decrypt_cbc() +
+  //test_encrypt_ctr() + test_decrypt_ctr() +
+  /*test_decrypt_ecb() + test_encrypt_ecb();*/
+    //test_encrypt_ecb_verbose();
 
     return exit;
 }
\ No newline at end of file
